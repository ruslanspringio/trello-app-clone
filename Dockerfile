# --- ЭТАП 1: СБОРКА ---
# Используем официальный образ Go как "сборочный стенд".
# `alpine` - это легковесная версия Linux.
FROM golang:1.25-alpine AS builder

# Устанавливаем рабочую директорию внутри контейнера.
WORKDIR /app

# Копируем файлы go.mod и go.sum, чтобы скачать зависимости.
# Это делается отдельным шагом для эффективного кэширования Docker.
COPY go.mod go.sum ./
RUN go mod download

# Копируем весь остальной исходный код.
COPY . .

# Собираем наше приложение.
# `CGO_ENABLED=0` - отключает CGO, что важно для статической компиляции.
# `go build ...` - компилирует main.go в один бинарный файл с именем `main`.
# `-o ./out/main` - указывает, куда положить результат.
RUN CGO_ENABLED=0 go build -o ./out/main ./cmd/main.go


# --- ЭТАП 2: ФИНАЛЬНЫЙ ОБРАЗ ---
# Используем `scratch` - это абсолютно пустой образ, самый минимальный и безопасный.
# Можно использовать `alpine`, если вам нужен shell внутри контейнера для отладки.
FROM scratch

# Устанавливаем рабочую директорию.
WORKDIR /app

# Копируем ТОЛЬКО скомпилированный бинарный файл из этапа "builder".
COPY --from=builder /app/out/main .

# Указываем, какой порт наше приложение будет слушать.
# Это для информации, реальное пробрасывание портов делается в docker-compose.
EXPOSE 8080

# Команда, которая будет выполнена при запуске контейнера.
# Запускаем наш скомпилированный бинарный файл.
ENTRYPOINT ["/app/main"]